/**
 * Generated by orval v8.0.0-rc.0 üç∫
 * Do not edit manually.
 * Hello API Platform
 * OpenAPI spec version: 1.0.0
 */
import type {
  ApiBooksGetCollection200,
  ApiBooksGetCollectionParams,
  Book,
  BookJsonld,
  ConstraintViolationJson,
  ConstraintViolationJsonldJsonld,
  Error,
  ErrorJsonld,
} from ".././models";

import { customFetch } from ".././custom-fetch";

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? A : B;

type WritableKeys<T> = {
  [P in keyof T]-?: IfEquals<
    { [Q in P]: T[P] },
    { -readonly [Q in P]: T[P] },
    P
  >;
}[keyof T];

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
  k: infer I,
) => void
  ? I
  : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>]
  ? {
      [P in keyof Writable<T>]: T[P] extends object
        ? NonReadonly<NonNullable<T[P]>>
        : T[P];
    }
  : DistributeReadOnlyOverUnions<T>;

/**
 * Retrieves the collection of Book resources.
 * @summary Retrieves the collection of Book resources.
 */
export type apiBooksGetCollectionResponse200 = {
  data: ApiBooksGetCollection200;
  status: 200;
};

export type apiBooksGetCollectionResponseSuccess =
  apiBooksGetCollectionResponse200 & {
    headers: Headers;
  };
export type apiBooksGetCollectionResponse =
  apiBooksGetCollectionResponseSuccess;

export const getApiBooksGetCollectionUrl = (
  params?: ApiBooksGetCollectionParams,
) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? "null" : value.toString());
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0
    ? `https://localhost:3000/books?${stringifiedParams}`
    : `https://localhost:3000/books`;
};

export const apiBooksGetCollection = async (
  params?: ApiBooksGetCollectionParams,
  options?: RequestInit,
): Promise<apiBooksGetCollectionResponse> => {
  return customFetch<apiBooksGetCollectionResponse>(
    getApiBooksGetCollectionUrl(params),
    {
      ...options,
      method: "GET",
    },
  );
};

/**
 * Creates a Book resource.
 * @summary Creates a Book resource.
 */
export type apiBooksPostResponse201 = {
  data: BookJsonld;
  status: 201;
};

export type apiBooksPostResponse400ApplicationLdJson = {
  data: ErrorJsonld;
  status: 400;
};

export type apiBooksPostResponse400ApplicationProblemJson = {
  data: Error;
  status: 400;
};

export type apiBooksPostResponse422ApplicationLdJson = {
  data: ConstraintViolationJsonldJsonld;
  status: 422;
};

export type apiBooksPostResponse422ApplicationProblemJson = {
  data: ConstraintViolationJson;
  status: 422;
};

export type apiBooksPostResponseSuccess = apiBooksPostResponse201 & {
  headers: Headers;
};
export type apiBooksPostResponseError = (
  | apiBooksPostResponse400ApplicationLdJson
  | apiBooksPostResponse400ApplicationProblemJson
  | apiBooksPostResponse422ApplicationLdJson
  | apiBooksPostResponse422ApplicationProblemJson
) & {
  headers: Headers;
};

export type apiBooksPostResponse =
  | apiBooksPostResponseSuccess
  | apiBooksPostResponseError;

export const getApiBooksPostUrl = () => {
  return `https://localhost:3000/books`;
};

export const apiBooksPost = async (
  bookJsonld: NonReadonly<BookJsonld>,
  options?: RequestInit,
): Promise<apiBooksPostResponse> => {
  return customFetch<apiBooksPostResponse>(getApiBooksPostUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/ld+json", ...options?.headers },
    body: JSON.stringify(bookJsonld),
  });
};

/**
 * Retrieves a Book resource.
 * @summary Retrieves a Book resource.
 */
export type apiBooksIdGetResponse200 = {
  data: BookJsonld;
  status: 200;
};

export type apiBooksIdGetResponse404ApplicationLdJson = {
  data: ErrorJsonld;
  status: 404;
};

export type apiBooksIdGetResponse404ApplicationProblemJson = {
  data: Error;
  status: 404;
};

export type apiBooksIdGetResponseSuccess = apiBooksIdGetResponse200 & {
  headers: Headers;
};
export type apiBooksIdGetResponseError = (
  | apiBooksIdGetResponse404ApplicationLdJson
  | apiBooksIdGetResponse404ApplicationProblemJson
) & {
  headers: Headers;
};

export type apiBooksIdGetResponse =
  | apiBooksIdGetResponseSuccess
  | apiBooksIdGetResponseError;

export const getApiBooksIdGetUrl = (id: string) => {
  return `https://localhost:3000/books/${id}`;
};

export const apiBooksIdGet = async (
  id: string,
  options?: RequestInit,
): Promise<apiBooksIdGetResponse> => {
  return customFetch<apiBooksIdGetResponse>(getApiBooksIdGetUrl(id), {
    ...options,
    method: "GET",
  });
};

/**
 * Removes the Book resource.
 * @summary Removes the Book resource.
 */
export type apiBooksIdDeleteResponse204 = {
  data: void;
  status: 204;
};

export type apiBooksIdDeleteResponse404ApplicationLdJson = {
  data: ErrorJsonld;
  status: 404;
};

export type apiBooksIdDeleteResponse404ApplicationProblemJson = {
  data: Error;
  status: 404;
};

export type apiBooksIdDeleteResponseSuccess = apiBooksIdDeleteResponse204 & {
  headers: Headers;
};
export type apiBooksIdDeleteResponseError = (
  | apiBooksIdDeleteResponse404ApplicationLdJson
  | apiBooksIdDeleteResponse404ApplicationProblemJson
) & {
  headers: Headers;
};

export type apiBooksIdDeleteResponse =
  | apiBooksIdDeleteResponseSuccess
  | apiBooksIdDeleteResponseError;

export const getApiBooksIdDeleteUrl = (id: string) => {
  return `https://localhost:3000/books/${id}`;
};

export const apiBooksIdDelete = async (
  id: string,
  options?: RequestInit,
): Promise<apiBooksIdDeleteResponse> => {
  return customFetch<apiBooksIdDeleteResponse>(getApiBooksIdDeleteUrl(id), {
    ...options,
    method: "DELETE",
  });
};

/**
 * Updates the Book resource.
 * @summary Updates the Book resource.
 */
export type apiBooksIdPatchResponse200 = {
  data: BookJsonld;
  status: 200;
};

export type apiBooksIdPatchResponse400ApplicationLdJson = {
  data: ErrorJsonld;
  status: 400;
};

export type apiBooksIdPatchResponse400ApplicationProblemJson = {
  data: Error;
  status: 400;
};

export type apiBooksIdPatchResponse404ApplicationLdJson = {
  data: ErrorJsonld;
  status: 404;
};

export type apiBooksIdPatchResponse404ApplicationProblemJson = {
  data: Error;
  status: 404;
};

export type apiBooksIdPatchResponse422ApplicationLdJson = {
  data: ConstraintViolationJsonldJsonld;
  status: 422;
};

export type apiBooksIdPatchResponse422ApplicationProblemJson = {
  data: ConstraintViolationJson;
  status: 422;
};

export type apiBooksIdPatchResponseSuccess = apiBooksIdPatchResponse200 & {
  headers: Headers;
};
export type apiBooksIdPatchResponseError = (
  | apiBooksIdPatchResponse400ApplicationLdJson
  | apiBooksIdPatchResponse400ApplicationProblemJson
  | apiBooksIdPatchResponse404ApplicationLdJson
  | apiBooksIdPatchResponse404ApplicationProblemJson
  | apiBooksIdPatchResponse422ApplicationLdJson
  | apiBooksIdPatchResponse422ApplicationProblemJson
) & {
  headers: Headers;
};

export type apiBooksIdPatchResponse =
  | apiBooksIdPatchResponseSuccess
  | apiBooksIdPatchResponseError;

export const getApiBooksIdPatchUrl = (id: string) => {
  return `https://localhost:3000/books/${id}`;
};

export const apiBooksIdPatch = async (
  id: string,
  book: NonReadonly<Book>,
  options?: RequestInit,
): Promise<apiBooksIdPatchResponse> => {
  return customFetch<apiBooksIdPatchResponse>(getApiBooksIdPatchUrl(id), {
    ...options,
    method: "PATCH",
    headers: {
      "Content-Type": "application/merge-patch+json",
      ...options?.headers,
    },
    body: JSON.stringify(book),
  });
};
